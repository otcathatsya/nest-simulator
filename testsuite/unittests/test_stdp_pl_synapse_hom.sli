/*
 *  test_stdp_pl_synapse_hom.sli
 *
 *  This file is part of NEST.
 *
 *  Copyright (C) 2004 The NEST Initiative
 *
 *  NEST is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  NEST is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with NEST.  If not, see <http://www.gnu.org/licenses/>.
 *
 */


/* BeginDocumentation
Name: testsuite::test_stdp_pl_synapse_hom - basic test of stdp_pl_synapse_hom

Synopsis: (test_stdp_pl_synapse_hom) run

Description:
  A parrot_neuron that repeats the spikes from a poisson generator is
  connected to an iaf_psc_alpha that is driven by inh. and exc. poisson input.
  The synapse is an stdp_pl_synapse_hom. After the simulation, we go through
  the pre- and postsyn. spike-trains spike by spike and try to reproduce the STDP
  results. The final weight obtained after simulation is compared to the final
  weight obtained from the test.

Author: Kunkel, Dec 2017
*/


(unittest) run
/unittest using
 
ResetKernel
 
/resolution 0.1 def %1.0 def %2.0 -4 pow def  % simulation step size
0 << /resolution resolution >> SetStatus %/tics_per_ms 10000.0 >> SetStatus


%%% input parameters %%%

/K_exc         8000.0 def  % number of exc. inputs
/K_inh         2000.0 def  % number of inh. inputs
/nu              10.0 def  % equil. firing rate
/nu_x             1.7 def  % external rate
/w_exc           45.0 def  % strength of exc. connections
/w_inh w_exc -5.0 mul def  % strength of inh. connections

/delay       1.0                      def  % synaptic transmission delay
/delay_steps delay resolution div cvi def  % synaptic transmission delay in steps

/axonal_delay 0                            def
/backpr_delay delay_steps axonal_delay sub def
%/axonal_delay 0.0 def
%/backpr_delay delay axonal_delay sub def


%%% STDP parameters %%%

/alpha      0.0513 def
/lambda     0.1    def
/tau_plus  15.0    def
/tau_minus 30.0    def
/mu         0.4    def


%%% create poisson generators, neurons and spike detector %%%

/pg_exc /poisson_generator << /rate K_exc nu nu_x add mul >> Create def
/pg_inh /poisson_generator << /rate K_inh nu mul          >> Create def

/pg_pre /poisson_generator << /rate nu >> Create def

/parrot /parrot_neuron Create def
/neuron /iaf_psc_alpha Create def

/spike_detector << /to_file       false
                   /to_memory     true
		   %/precision 15
		   /time_in_steps true
                >> SetDefaults
/sd_pre  /spike_detector Create def
/sd_post /spike_detector Create def


%%% connect %%%

/stdp_pl_synapse_hom << /alpha     alpha
                        /lambda    lambda
		        /tau_plus  tau_plus
		        /tau_minus tau_minus
		        /mu        mu
                     >> SetDefaults

pg_exc neuron w_exc delay Connect
pg_inh neuron w_inh delay Connect
pg_pre parrot w_exc delay Connect

parrot neuron w_exc delay /stdp_pl_synapse_hom Connect

parrot sd_pre  Connect
neuron sd_post Connect


%%% simulate and get data %%%

10000.0 Simulate

/pre_spikes  sd_pre  GetStatus /events get /times get cva { axonal_delay add } Map def
/post_spikes sd_post GetStatus /events get /times get cva { backpr_delay add } Map def

/final_weight << /source [parrot] /target [neuron] >> GetConnections 0 get /weight get def


%%% check final weight %%%

cout 15 setprecision

/K_plus    0.0 def
/K_minus   0.0 def
/last_pre  0   def
/last_post 0   def
/j         0   def
/i         0   def

/post_spike post_spikes i get def
/pre_spike  pre_spikes  j get def
/w          w_exc             def

/update_K_plus
{
  last_pre pre_spike sub resolution mul tau_plus div exp K_plus mul 1.0 add /K_plus Set
  %last_pre pre_spike sub tau_plus div exp K_plus mul 1.0 add /K_plus Set
  %(K_plus = ) =only K_plus =
}
def

/update_K_minus
{
  last_post post_spike sub resolution mul tau_minus div exp K_minus mul 1.0 add /K_minus Set
  %last_post post_spike sub tau_minus div exp K_minus mul 1.0 add /K_minus Set
  %(K_minus = ) =only K_minus =
}
def

/next_pre_spike
{
  j 1 add /j Set
  pre_spike /last_pre Set
  pre_spikes j get /pre_spike Set  
}
def

/next_post_spike
{
  i 1 add /i Set
  post_spike /last_post Set
  post_spikes i get /post_spike Set
}
def

/facilitate
{
  ( w + lambda * w**mu * K_plus * exp( ( last_pre - post_spike ) * resolution / tau_plus ) ) ExecMath /w Set
  %( w + lambda * w**mu * K_plus * exp( ( last_pre - post_spike ) / tau_plus ) ) ExecMath /w Set
  %(facilitation) =only (\t) =only last_pre =only (\t) =only post_spike =only (\t) =only w =
}
def

/depress
{
  ( w - lambda * alpha * w * K_minus * exp( ( last_post - pre_spike ) * resolution / tau_minus ) ) ExecMath
  %( w - lambda * alpha * w * K_minus * exp( ( last_post - pre_spike ) / tau_minus ) ) ExecMath
  dup 0.0 gt { /w Set } { pop 0.0 /w Set } ifelse
  %(depression) =only (\t) =only last_post =only (\t) =only pre_spike =only (\t) =only w =
}
def


{
  {
    pre_spike post_spike eq
    { % pre- and post-syn. spike at the same time
      last_post post_spike neq { facilitate } if
      last_pre pre_spike neq { depress } if
      %(pre == post) =only (\t) =only pre_spike =only (\t) =only post_spike =only (\t) =only w =
      j 1 add pre_spikes length lt
      {
        update_K_plus
        next_pre_spike
        i 1 add post_spikes length lt
        {
          update_K_minus
  	next_post_spike
        }
        if
      }
      {
        exit  
      }
      ifelse
    }
    {
      pre_spike post_spike lt
      { % next spike is a pre-syn. spike
        depress
        update_K_plus
        j 1 add pre_spikes length lt
        {
          next_pre_spike
        }
        {
          %(last presyn spike) =
          % we don't consider the post-syn. spikes after the last pre-syn. spike
          exit
        }
        ifelse
      }
      { % next spike is a post-syn. spike
        facilitate
        update_K_minus
        i 1 add post_spikes length lt
        {
          next_post_spike
        }
        {
          %(last postsyn spike) =
          % we DO consider the pre-syn. spikes after the last post-syn. spike
          post_spike /last_post Set
          pre_spikes dup length 1 sub get 1 add /post_spike Set  % to make sure we don't come here again
          %pre_spikes dup length 1 sub get resolution add /post_spike Set  % to make sure we don't come here again
        }
        ifelse
      }
      ifelse
    }
    ifelse
  }
  loop

  %w ==
  %final_weight ==
  w 13 ToUnitTestPrecision final_weight 13 ToUnitTestPrecision eq
} assert_or_die
